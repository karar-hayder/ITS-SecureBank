SECUREBANK — CORE BANKING API
HACKATHON REQUIREMENTS

Duration: 2 Days
Objective: Build a ledger-based core banking API that guarantees money is never lost, duplicated, or partially applied — even under crashes, malicious input, and high concurrency.

This system is evaluated on correctness, resilience, and clarity of architectural reasoning, not feature volume.

----------------------------------------------------------------
1. CORE BANKING PRINCIPLES (NON-NEGOTIABLE)
----------------------------------------------------------------

The system MUST uphold the following invariants at all times:

1. Money Conservation
- Money cannot be created or destroyed except through explicit operations (deposit, interest).
- Transfers must have net-zero effect across the system.

2. Atomicity
- Every monetary operation must be all-or-nothing.
- Partial state (e.g., debit without credit) is forbidden.

3. Consistency
- Account balances must never be negative.
- Account balance must reconcile with transaction history.

4. Isolation
- Concurrent requests must not interfere with each other.
- Double spending must be impossible, even under simultaneous requests.

5. Durability
- Once a transaction is committed, it must survive crashes and restarts.

Violating any invariant constitutes system failure.

----------------------------------------------------------------
2. THREAT MODEL
----------------------------------------------------------------

The system must behave correctly under the following conditions:

2.1 Infrastructure Failures
- Server crash during request execution
- Power loss mid-transaction
- Database restart

2.2 Malicious or Invalid Inputs (Zero Trust)
- Negative or zero amounts
- Forged account identifiers
- Unauthorized access attempts
- Request replays (duplicate submissions)

2.3 High Concurrency
- Multiple transfers from the same account at the same millisecond
- Concurrent deposits, withdrawals, and transfers

----------------------------------------------------------------
3. DOMAIN MODEL
----------------------------------------------------------------

3.1 User
Represents an authenticated identity.

Minimum Fields:
- id
- email (unique)
- password_hash
- full_name
- created_at

----------------------------------------------------------------

3.2 Account
Represents a financial container owned by a user.

Rules:
- A user may own multiple accounts (e.g., Checking, Savings).
- Each account must have a globally unique business identifier.
- Balance must never be negative.

Minimum Fields:
- id
- owner_user_id
- account_number (unique)
- account_type (CHECKING | SAVINGS)
- account_status (PENDING | ACTIVE | INACTIVE | SUSPENDED | CLOSED)
- balance (DECIMAL / fixed-point)
- created_at
- updated_at
- account_level (1 | 2 | 3) (For benefits like interest rate, transaction fee, transaction volume, etc.)

NOTE:
Balance is derived state and must always reconcile with the ledger.

----------------------------------------------------------------

3.3 Transaction (Ledger Entry)
Immutable record of every money movement.

Rules:
- Every monetary operation must create one or more transactions.
- Transactions are append-only and never updated or deleted.

Minimum Fields:
- id
- account_id
- type (DEBIT | CREDIT)
- amount (positive, fixed-point)
- reference_id (shared identifier for grouped operations)
- description
- created_at

----------------------------------------------------------------
4. CORE FUNCTIONAL REQUIREMENTS
----------------------------------------------------------------

4.1 Authentication

POST /auth/register
- Registers a new user
- Automatically provisions a default Checking account

POST /auth/login
- Authenticates user
- Returns a JWT

All protected endpoints require authentication.

----------------------------------------------------------------

4.2 Account Management

POST /accounts
- Creates a supplementary account for the authenticated user

GET /accounts
- Returns all accounts owned by the user
- Includes real-time balances

----------------------------------------------------------------

4.3 Deposits

POST /accounts/{id}/deposit

Rules:
- Amount must be > 0
- Creates a CREDIT ledger entry
- Operation must be atomic

----------------------------------------------------------------

4.4 Withdrawals

POST /accounts/{id}/withdraw

Rules:
- Amount must be > 0
- Sufficient funds required
- Creates a DEBIT ledger entry
- Operation must be atomic

----------------------------------------------------------------
5. TRANSFERS (CORE BANKING OPERATION)
----------------------------------------------------------------

POST /transfer

Input Payload:
{
  "fromAccountId": "...",
  "toAccountNumber": "...",
  "amount": 100.00
}

Transfer Invariants:
1. Sender must own the source account
2. Destination account must exist
3. Amount must be positive
4. Source account must have sufficient funds
5. Operation must be fully atomic
6. Operation must be concurrency-safe
7. Two ledger entries must be recorded:
   - DEBIT for sender
   - CREDIT for receiver

Atomicity Guarantee:
- Either both ledger entries are committed
- Or no state change occurs at all

No half-done states are allowed.

----------------------------------------------------------------
6. CONCURRENCY & ISOLATION REQUIREMENTS
----------------------------------------------------------------

The system must prevent double spending.

Naive logic that:
- Reads balance
- Validates
- Updates later
is unacceptable.

The implementation must ensure that:
- Only one transaction can affect an account’s spendable balance at a time

If perfect implementation is not possible, a clear and correct strategy must be explained.

----------------------------------------------------------------
7. AUDITABILITY
----------------------------------------------------------------

GET /accounts/{id}/transactions

Requirements:
- Returns full transaction history for the account
- Results must be paginated
- An auditor must be able to reconstruct the balance from this data alone

Optional:
- Export transactions as CSV or XLSX

----------------------------------------------------------------
8. DATA & ERROR HANDLING STANDARDS
----------------------------------------------------------------

8.1 Financial Data Types
- Floating point types are forbidden
- Use DECIMAL / NUMERIC or smallest currency unit (e.g., cents)

8.2 Error Handling
- Errors must be deterministic and descriptive
- No generic 500 errors for business rule violations
- No internal system details leaked

----------------------------------------------------------------
9. BONUS (HIGH-VALUE FEATURES)
----------------------------------------------------------------

1. Idempotency
- Replaying the same request must not duplicate effects

2. Interest Job
- Background process applying 0.01% interest to Savings accounts
- Must be concurrency-safe

3. Additional Enhancements
- Any feature that improves safety, auditability, or correctness

----------------------------------------------------------------
10. EVALUATION CRITERIA
----------------------------------------------------------------

Judges will prioritize:
- Correctness over completeness
- Clear core banking reasoning
- Ability to explain failure scenarios
- Confidence in concurrency and atomicity strategy

One bulletproof transfer is worth more than ten unstable features.

----------------------------------------------------------------
END OF SPECIFICATION
----------------------------------------------------------------