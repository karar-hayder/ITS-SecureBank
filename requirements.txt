Hackathon Project: SecureBank
Duration: 2 Days
Goal: Build a secure, transactional banking API where users can deposit, withdraw, and transfer
money without losing a single cent.

1. The Scenario
You have been hired to build the backend for a new digital bank. Banking apps look simple on the
surface, but in the real world, they are incredibly fragile.
Your stakeholders are paranoid about Data Integrity. They have asked you to build a system that can
survive:

Your job is not just to make it work, but to ensure it never breaks.
‚ö†Ô∏è Scope & Expectations
We understand that 2 days is a tight deadline.
While a fully finished application is the goal, the judges prioritize architectural correctness and
handling of edge cases over feature quantity.

2. Domain Modeling
You are responsible for designing the database schema. You may add fields as necessary, but the
following are the minimum requirements:
1. Server Crashes: Power failures happening in the exact middle of a request.
2. Hackers: Malicious users trying to manipulate inputs.
3. High Concurrency: Two users (or the same user) clicking "Transfer" at the exact same
millisecond.

If you cannot implement a perfect concurrency solution in code, be prepared to explain your
strategy clearly to the judges.
For example, it is better to have one bulletproof "Transfer" endpoint than 10 buggy features.

1. User: Standard identity management (Id, Email, PasswordHash, FullName, etc.).
2. Account:
A user can have multiple accounts (e.g., Savings, Checking).
Accounts must have a unique business identifier (e.g., IBAN or 10-digit Account Number).
Constraint: An account balance can never be negative.
3. Transaction History:
Every single movement of money (In or Out) must be recorded.

3. Core Features (User Stories)
A. Authentication

B. Wallet Operations

C. The Transfer (The Core Challenge)

4. Critical System Behaviors (Pass/Fail Criteria)
This is a hackathon. We are not testing if you can write a controller; we are testing if you can build a
resilient system.
1. Atomicity (The "Crash" Test)
Imagine the power cord is pulled out of the server after you deduct money from User A, but before you
add it to User B.

2. Race Conditions (The "Double Spend" Attack)
What happens if a user with $100 sends two requests at the exact same millisecond to transfer $100?
Auditors need to be able to trace exactly where every cent came from and where it went.

POST /auth/register: Register a new user and automatically provision an initial Checking account.
POST /auth/login: Authenticate and return a JWT.

POST /accounts: Create a supplementary account.
GET /accounts: View all accounts belonging to the user with real-time balances.
POST /accounts/{id}/deposit: Add money (Simulates an ATM deposit).
POST /accounts/{id}/withdraw: Remove money.
Validation: Verify sufficient funds before processing.

POST /transfer: Move money from Account A to Account B.
Payload: { fromAccountId, toAccountNumber, amount }
Logic:
1. Verify the sender owns the source account.
2. Locate the destination account (using the unique Account Number).
3. Execute the movement of funds atomically.
4. Persist transaction records for both the sender and the receiver.

Requirement: The system must guarantee that money is never lost. The transfer must either fully
succeed or fully fail. No "half-done" states are allowed.

3. Input Security (The "Zero Trust" Test)

4. Auditability

üß† Things to Think About (No Hints Allowed!)

üèÜ Bonus Challenges
Implement these high-value features to stand out:
The Risk: Naive systems will read the balance ($100) for both requests, pass the validation check,
and allow the user to spend $200 total.
Requirement: Your system must handle high concurrency. You must demonstrate how you prevent
this "Double Spend" scenario.

Users are unpredictable. They might try to transfer negative amounts, zero amounts, or manipulate
IDs to transfer money they don't own.
Requirement: Implement strict validation. Assume every input is an attack.
Edge Case: Should a user be allowed to transfer money to themselves? Ensure this logic is
handled deliberately.

Requirement: An auditor must be able to query GET /accounts/{id}/transactions and
reconstruct the history of the account balance.
Requirement: This endpoint must be Paginated to handle large datasets.

1. Data Types: What is the industry standard data type for financial calculations? (Choosing the
wrong one leads to floating-point rounding errors and pennies might be lost over time).
2. Error Handling: If a transfer fails, does the user receive a generic 500 error, or a descriptive,
actionable message?
3. Isolation: When you read a balance to check for sufficient funds, how do you ensure no one else is
changing that balance in that exact microsecond?

1. Export to CSV: Allow auditors to download transaction history as a .csv or .xlsx file.
2. Interest Calculation: Create a background job that runs every few seconds (to be demonstrated)
to add 0.01% interest to all "Savings" accounts.
3. Idempotency: Ensure that if the client retries the same API call due to network lag, the operation is
not performed twice.
4. Feel free to add any additional feature that you see is beneficial and valuable to the system.